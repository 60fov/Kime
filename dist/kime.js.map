{"version":3,"file":"kime.js","sources":["../src/hooks/useKime.ts"],"sourcesContent":["import { type RefObject, useCallback, useEffect, useRef, useState } from \"react\"\nimport kime from \"../kime\"\nimport { jamo, decomposeBlock, compose } from \"../kime/jamo\"\n\n// TODO: clean up\n\nexport interface KimeInput {\n    value: string\n    clear: () => void\n    setValue: (v: string) => void\n}\n\nconst useKime = (\n    // TODO: consider content editable elements\n    inputRef: RefObject<HTMLInputElement>,\n    // options?: AddEventListenerOptions\n    ): { input: KimeInput, composing: boolean } => {\n\n    const [composing, setComposing] = useState(false)\n    const [value, setValue] = useState('')\n\n\n    function dispatchKimeInputEvent(v: string) {\n        inputRef.current?.dispatchEvent(new CustomEvent('kimeinput', {\n            detail: { value: v }\n        }))\n    }\n\n    const onKeyDown = useCallback((e: KeyboardEvent) => {\n        const typedJamo = jamo.single.includes(e.key) ? e.key : kime.keyLookUp(e.key)\n\n        if (typedJamo) {\n            if (e.altKey || e.metaKey || e.ctrlKey) return\n            e.preventDefault()\n            const splitInput = value.split('')\n            if (composing) {\n                // note: block should not be able to be undefined here since composing\n                const block = splitInput.pop() ?? ''\n                const ending = kime.compose([...kime.decompose(block), typedJamo])\n                splitInput.push(...ending)\n                const newValue = splitInput.join('')\n                dispatchKimeInputEvent(newValue)\n            } else {\n                dispatchKimeInputEvent(value + typedJamo)\n                setComposing(true)\n            }\n\n        } else if (e.key.length === 1) {\n            if (e.altKey || e.metaKey || e.ctrlKey) return\n            // TODO: audit e.key.length === 1\n            // is there a non typabled key with a length of 1?\n            e.preventDefault()\n            setComposing(false)\n            dispatchKimeInputEvent(value + e.key)\n\n        } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {\n            e.preventDefault()\n        } else if (e.key === 'Backspace') {\n            e.preventDefault()\n            // TODO: consider mac vs windows\n            if (e.ctrlKey || e.metaKey) {\n                dispatchKimeInputEvent('')\n            } else {\n                const splitInput = value.split('')\n                const last = splitInput.pop()\n                if (composing && last) {\n                    const dl = decomposeBlock(last)\n                    dl.pop()\n                    if (dl.length) {\n                        splitInput.push(compose(dl).join(''))\n                    } else {\n                        setComposing(false)\n                    }\n                }\n                const newValue = splitInput.join('')\n                dispatchKimeInputEvent(newValue)\n            }\n\n        } else if (e.key === 'Enter') {\n            // TODO: consider submitevent\n            // const event = new CustomEvent('enter', { detail: { value: inputRef.current.value } })\n            // inputRef.current.dispatchEvent(event)\n\n        } else if (e.key === 'Escape') {\n            setComposing(false)\n        }\n        else {\n            // ???\n            // console.log('key???', e.key)\n            // TODO: leave console user feedback note if someone checks this\n        }\n    }, [composing, value])\n\n\n    const onKimeInput = (e: Event) => {\n        const event = e as CustomEvent<{ value: string }>\n        setValue(event.detail.value)\n    }\n\n    const keyDownHandlerRef = useRef(onKeyDown)\n\n    useEffect(() => {\n        keyDownHandlerRef.current = onKeyDown\n    })\n\n    useEffect(() => {\n        const inputElement = inputRef?.current\n        if (!inputElement) return\n\n\n\n        // readonly makes virtual kb not show up\n        // TODO: make readonly param\n        // inputElement.readOnly = true\n\n        const internalKeyDownHandler = (e: KeyboardEvent) => keyDownHandlerRef.current(e)\n        inputElement.addEventListener('keydown', internalKeyDownHandler)\n        inputElement.addEventListener('kimeinput', onKimeInput)\n        return () => {\n            inputElement.removeEventListener('keydown', internalKeyDownHandler)\n            inputElement.removeEventListener('kimeinput', onKimeInput)\n        }\n    }, [])\n\n    return {\n        input: {\n            value,\n            clear: () => setValue(''),\n            setValue\n        },\n        composing\n    }\n\n}\n\nexport default useKime"],"names":["useKime","inputRef","composing","setComposing","useState","value","setValue","dispatchKimeInputEvent","v","_a","onKeyDown","useCallback","typedJamo","jamo","kime","splitInput","block","ending","newValue","last","dl","decomposeBlock","compose","onKimeInput","keyDownHandlerRef","useRef","useEffect","inputElement","internalKeyDownHandler","e"],"mappings":"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"}